<!DOCTYPE html>
<html>
<head>
    <title>Queen Puzzle Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.3.4/vue.global.min.js"></script>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        
        #app {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 1200px;
            padding: 20px;
        }
        
        .board-container {
            display: flex;
            justify-content: center;
            width: 100%;
        }
        
        .board {
            display: inline-grid;
            gap: 1px;
            background: #333;
            padding: 1px;
            margin: 20px auto;
        }
        
        .cell {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* IE10+/Edge */
        }
        
        .cell:hover {
            opacity: 0.8;
        }
        
        .mark-x {
            font-weight: bold;
        }
        
        .mark-queen {
            width: 40px;
            height: 40px;
            object-fit: contain;
        }
        
        .controls {
            text-align: center;
            margin-bottom: 1rem;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
            width: 100%;
        }
        
        .timer {
            font-size: 1rem;
            padding: 0.5rem 1rem;
            margin: 0.5rem;
            background-color: #2196F3;
            color: white;
            border-radius: 5px;
            min-width: 100px;
            text-align: center;
        }
        
        button {
            font-size: 1rem;
            padding: 0.5rem 1rem;
            margin: 0.5rem;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        
        button:hover {
            background-color: #45a049;
        }

        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal {
            background-color: white;
            padding: 2rem;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            animation: pop 0.3s ease-out;
            min-width: 300px;
        }

        .button-container {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
        }

        @keyframes pop {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        .modal h2 {
            color: #4CAF50;
            margin-top: 0;
        }

        .modal p {
            margin: 1rem 0;
        }
        
        .modal .close-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="controls">
            <div class="timer">{{ formattedTime }}</div>
            <button @click="startNewGame">New Game</button>
            <button @click="resetGame" class="reset">Reset Current Game</button>
            <button @click="backToMenu">Back to Menu</button>
        </div>
        <div class="board" 
             :style="boardStyle"
             @mouseup="handleMouseUp"
             @mouseleave="handleMouseLeave">
            <template v-for="(row, i) in state.regions">
                <div v-for="(cell, j) in row" 
                     :key="`${i}-${j}`"
                     class="cell"
                     :class="{ 'dragging': isDragging }"
                     :style="getCellStyle(i, j)"
                     @mousedown="handleMouseDown($event, i, j)"
                     @mouseenter="handleMouseEnter(i, j)"
                     @mouseup.stop="handleCellMouseUp(i, j)">
                    <span v-if="state.marks[i][j] === 1" class="mark-x">X</span>
                    <img v-if="state.marks[i][j] === 2" 
                         src="/static/black_queen_logo.png" 
                         alt="Queen" 
                         class="mark-queen">
                </div>
            </template>
        </div>
        <!-- Victory Modal -->
        <div v-if="showVictoryModal" class="modal-overlay" @click="hideModal">
            <div class="modal" @click.stop>
                <h2>ðŸŽ‰ Congratulations! ðŸŽ‰</h2>
                <p>You've found all the queens in {{ formattedTime }}!</p>
                <div class="button-container">
                    <button @click="startNewGame">New Game</button>
                    <button @click="hideModal">Continue Viewing</button>
                    <button @click="backToMenu">Back to Menu</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp } = Vue;
        
        const app = createApp({
            data() {
                return {
                    state: {
                        regions: [],
                        marks: [],
                        size: 8
                    },
                    showVictoryModal: false,
                    colors: [
                        '#FF0000', // Red
                        '#00FF00', // Lime
                        '#0000FF', // Blue
                        '#FFD700', // Gold
                        '#FF00FF', // Magenta
                        '#AFEEEE', // Cyan
                        '#FFBF00', // Amber
                        '#8B4513', // Saddle Brown
                        '#1E90FF', // Dodger Blue
                        '#3CB371', // Medium Sea Green
                        '#FF1493', // Deep Pink
                        '#4B0082', // Indigo
                        '#87CEEB', // Sky Blue
                        '#FF4500', // Orange Red
                        '#556B2F'  // Dark Olive Green
                    ],
                    isDragging: false,
                    mouseDownCell: null,
                    lastCell: null,
                    hasMoved: false,
                    initialMarkState: null,
                    startTime: null,
                    elapsedTime: 0,
                    timerInterval: null
                }
            },
            computed: {
                boardStyle() {
                    return {
                        'grid-template-columns': `repeat(${this.state.size}, 60px)`
                    }
                },
                formattedTime() {
                    const totalSeconds = Math.floor(this.elapsedTime / 1000);
                    const minutes = Math.floor(totalSeconds / 60);
                    const seconds = totalSeconds % 60;
                    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
            },
            methods: {
                startTimer() {
                    // Clear any existing timer
                    if (this.timerInterval) {
                        clearInterval(this.timerInterval);
                    }
                    
                    // Reset and start timer
                    this.startTime = Date.now() - this.elapsedTime;
                    this.timerInterval = setInterval(() => {
                        this.elapsedTime = Date.now() - this.startTime;
                    }, 1000);
                },

                stopTimer() {
                    if (this.timerInterval) {
                        clearInterval(this.timerInterval);
                        this.timerInterval = null;
                    }
                },

                resetTimer() {
                    this.stopTimer();
                    this.elapsedTime = 0;
                    this.startTimer();
                },

                handleMouseDown(event, row, col) {
                    // Store the cell where mousedown occurred and its initial state
                    this.mouseDownCell = { row, col };
                    this.initialMarkState = this.state.marks[row][col];
                    this.hasMoved = false;
                    
                    // If it's an empty cell, mark it with X immediately
                    if (this.state.marks[row][col] === 0) {
                        this.toggleMarkX(row, col);
                    }
                    
                    // Prevent default to avoid text selection
                    event.preventDefault();
                },

                handleMouseUp() {
                    // Reset all tracking variables
                    this.isDragging = false;
                    this.lastCell = null;
                    this.mouseDownCell = null;
                    this.hasMoved = false;
                },

                handleMouseLeave() {
                    this.isDragging = false;
                    this.lastCell = null;
                    this.mouseDownCell = null;
                    this.hasMoved = false;
                },

                handleCellMouseUp(row, col) {
                    // Only process as a click if:
                    // 1. We haven't moved AND
                    // 2. We're on the same cell we started on AND
                    // 3. The initial state was either empty (0) or X (1)
                    if (!this.hasMoved && 
                        this.mouseDownCell && 
                        this.mouseDownCell.row === row && 
                        this.mouseDownCell.col === col &&
                        this.initialMarkState !== 0) { // Don't process if we started on an empty cell
                        this.toggleMark(row, col);
                    }
                    
                    this.handleMouseUp();
                },

                handleMouseEnter(row, col) {
                    if (this.mouseDownCell) {
                        // If we enter a new cell while holding mouse button,
                        // we've officially started dragging
                        this.hasMoved = true;
                        this.isDragging = true;
                        
                        // Mark X if it's an empty cell
                        if (this.state.marks[row][col] === 0) {
                            this.toggleMarkX(row, col);
                        }
                        
                        this.lastCell = `${row}-${col}`;
                    }
                },

                getCellStyle(i, j) {
                    return {
                        backgroundColor: this.colors[this.state.regions[i][j]]
                    }
                },

                async toggleMarkX(row, col) {
                    if (this.state.marks[row][col] === 0) {
                        const response = await fetch(`/api/toggle/${row}/${col}`, {
                            credentials: 'include'
                        });
                        const data = await response.json();
                        this.state.marks[row][col] = data.mark;
                    }
                },

                async toggleMark(row, col) {
                    const response = await fetch(`/api/toggle/${row}/${col}`, {
                        credentials: 'include'
                    });
                    const data = await response.json();
                    this.state.marks[row][col] = data.mark;
                    this.checkVictory();
                },
                async resetGame() {
                    const response = await fetch('/api/reset', {
                        method: 'POST',
                        credentials: 'include'
                    });
                    if (response.ok) {
                        this.state.marks = Array(this.state.size).fill().map(() => 
                            Array(this.state.size).fill(0)
                        );
                    }
                },
                async loadState() {
                    const urlParams = new URLSearchParams(window.location.search);
                    const size = urlParams.get('size');
                    const gameNumber = urlParams.get('game');
                    
                    let response;
                    if (size && gameNumber !== null) {
                        response = await fetch(`/api/select_game/${size}/${gameNumber}`, {
                            credentials: 'include'
                        });
                    } else {
                        response = await fetch('/api/state', {
                            credentials: 'include'
                        });
                    }
                    
                    if (response.ok) {
                        this.state = await response.json();
                        this.resetTimer();
                    } else {
                        console.error('Failed to load game');
                        window.location.href = '/';
                    }
                },
                checkVictory() {
                    const regionQueens = new Array(this.state.size).fill(0);
                    for (let i = 0; i < this.state.size; i++) {
                        for (let j = 0; j < this.state.size; j++) {
                            if (this.state.marks[i][j] === 2) {
                                regionQueens[this.state.regions[i][j]]++;
                            }
                        }
                    }
                    if (regionQueens.every(count => count === 1)) {
                        this.stopTimer();
                        this.showVictoryModal = true;
                    }
                },
                hideModal() {
                    this.showVictoryModal = false;
                },
                async startNewGame() {
                    const urlParams = new URLSearchParams(window.location.search);
                    const size = urlParams.get('size');
                    
                    if (size >= 12) {
                        window.location.href = `/select_game/${size}`;
                    } else {
                        const response = await fetch(`/api/new_game/${this.state.size}`, {
                            credentials: 'include'
                        });
                        if (response.ok) {
                            this.showVictoryModal = false;
                            this.state = await response.json();
                            this.resetTimer();
                        }
                    }
                },
                backToMenu() {
                    window.location.href = '/';
                }
            },
            mounted() {
                this.loadState();
            },
            beforeUnmount() {
                this.stopTimer();
            }
        });

        app.mount('#app');
    </script>
</body>
</html>